//! Data structures for forensic reports
//!
//! This module defines all the types used to represent forensic report data.
//! These structures are serializable and can be used with templates and output generators.

use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};

/// Main forensic report structure containing all report data
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ForensicReport {
    /// Report metadata
    pub metadata: ReportMetadata,
    /// Case information
    pub case_info: CaseInfo,
    /// Examiner information
    pub examiner: ExaminerInfo,
    /// Executive summary (can be AI-generated)
    pub executive_summary: Option<String>,
    /// Scope and objectives of the examination
    pub scope: Option<String>,
    /// Methodology used
    pub methodology: Option<String>,
    /// Evidence items examined
    pub evidence_items: Vec<EvidenceItem>,
    /// Chain of custody records
    pub chain_of_custody: Vec<CustodyRecord>,
    /// Findings from the examination
    pub findings: Vec<Finding>,
    /// Timeline of events (if applicable)
    pub timeline: Vec<TimelineEvent>,
    /// Hash verification records
    pub hash_records: Vec<HashRecord>,
    /// Tools and versions used
    pub tools: Vec<ToolInfo>,
    /// Conclusions
    pub conclusions: Option<String>,
    /// Appendices
    pub appendices: Vec<Appendix>,
    /// Additional notes
    pub notes: Option<String>,
}

impl ForensicReport {
    /// Create a new report builder
    pub fn builder() -> ForensicReportBuilder {
        ForensicReportBuilder::default()
    }

    /// Validate the report for completeness
    pub fn validate(&self) -> Result<(), Vec<String>> {
        let mut errors = Vec::new();

        if self.case_info.case_number.is_empty() {
            errors.push("Case number is required".to_string());
        }
        if self.examiner.name.is_empty() {
            errors.push("Examiner name is required".to_string());
        }
        if self.evidence_items.is_empty() {
            errors.push("At least one evidence item is required".to_string());
        }

        if errors.is_empty() {
            Ok(())
        } else {
            Err(errors)
        }
    }
}

/// Builder for creating ForensicReport instances
#[derive(Debug, Default)]
pub struct ForensicReportBuilder {
    metadata: Option<ReportMetadata>,
    case_info: Option<CaseInfo>,
    examiner: Option<ExaminerInfo>,
    executive_summary: Option<String>,
    scope: Option<String>,
    methodology: Option<String>,
    evidence_items: Vec<EvidenceItem>,
    chain_of_custody: Vec<CustodyRecord>,
    findings: Vec<Finding>,
    timeline: Vec<TimelineEvent>,
    hash_records: Vec<HashRecord>,
    tools: Vec<ToolInfo>,
    conclusions: Option<String>,
    appendices: Vec<Appendix>,
    notes: Option<String>,
}

impl ForensicReportBuilder {
    /// Set report metadata
    pub fn metadata(mut self, metadata: ReportMetadata) -> Self {
        self.metadata = Some(metadata);
        self
    }

    /// Set case number (creates minimal CaseInfo)
    pub fn case_number(mut self, case_number: impl Into<String>) -> Self {
        let mut info = self.case_info.unwrap_or_default();
        info.case_number = case_number.into();
        self.case_info = Some(info);
        self
    }

    /// Set full case info
    pub fn case_info(mut self, case_info: CaseInfo) -> Self {
        self.case_info = Some(case_info);
        self
    }

    /// Set examiner name (creates minimal ExaminerInfo)
    pub fn examiner_name(mut self, name: impl Into<String>) -> Self {
        let mut info = self.examiner.unwrap_or_default();
        info.name = name.into();
        self.examiner = Some(info);
        self
    }

    /// Set full examiner info
    pub fn examiner(mut self, examiner: ExaminerInfo) -> Self {
        self.examiner = Some(examiner);
        self
    }

    /// Set executive summary
    pub fn executive_summary(mut self, summary: impl Into<String>) -> Self {
        self.executive_summary = Some(summary.into());
        self
    }

    /// Set scope
    pub fn scope(mut self, scope: impl Into<String>) -> Self {
        self.scope = Some(scope.into());
        self
    }

    /// Set methodology
    pub fn methodology(mut self, methodology: impl Into<String>) -> Self {
        self.methodology = Some(methodology.into());
        self
    }

    /// Add an evidence item
    pub fn add_evidence(mut self, item: EvidenceItem) -> Self {
        self.evidence_items.push(item);
        self
    }

    /// Add multiple evidence items
    pub fn evidence_items(mut self, items: Vec<EvidenceItem>) -> Self {
        self.evidence_items = items;
        self
    }

    /// Add a custody record
    pub fn add_custody_record(mut self, record: CustodyRecord) -> Self {
        self.chain_of_custody.push(record);
        self
    }

    /// Add a finding
    pub fn add_finding(mut self, finding: Finding) -> Self {
        self.findings.push(finding);
        self
    }

    /// Add multiple findings
    pub fn findings(mut self, findings: Vec<Finding>) -> Self {
        self.findings = findings;
        self
    }

    /// Add a timeline event
    pub fn add_timeline_event(mut self, event: TimelineEvent) -> Self {
        self.timeline.push(event);
        self
    }

    /// Add a hash record
    pub fn add_hash_record(mut self, record: HashRecord) -> Self {
        self.hash_records.push(record);
        self
    }

    /// Add a tool info
    pub fn add_tool(mut self, tool: ToolInfo) -> Self {
        self.tools.push(tool);
        self
    }

    /// Set conclusions
    pub fn conclusions(mut self, conclusions: impl Into<String>) -> Self {
        self.conclusions = Some(conclusions.into());
        self
    }

    /// Add an appendix
    pub fn add_appendix(mut self, appendix: Appendix) -> Self {
        self.appendices.push(appendix);
        self
    }

    /// Set notes
    pub fn notes(mut self, notes: impl Into<String>) -> Self {
        self.notes = Some(notes.into());
        self
    }

    /// Build the ForensicReport
    pub fn build(self) -> Result<ForensicReport, String> {
        let case_info = self.case_info.ok_or("Case info is required")?;
        let examiner = self.examiner.ok_or("Examiner info is required")?;

        let metadata = self.metadata.unwrap_or_else(|| ReportMetadata {
            title: format!("Forensic Examination Report - Case {}", case_info.case_number),
            report_number: format!("RPT-{}", case_info.case_number),
            version: "1.0".to_string(),
            classification: Classification::Confidential,
            generated_at: Utc::now(),
            generated_by: "FFX Forensic File Xplorer".to_string(),
        });

        Ok(ForensicReport {
            metadata,
            case_info,
            examiner,
            executive_summary: self.executive_summary,
            scope: self.scope,
            methodology: self.methodology,
            evidence_items: self.evidence_items,
            chain_of_custody: self.chain_of_custody,
            findings: self.findings,
            timeline: self.timeline,
            hash_records: self.hash_records,
            tools: self.tools,
            conclusions: self.conclusions,
            appendices: self.appendices,
            notes: self.notes,
        })
    }
}

/// Report metadata
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ReportMetadata {
    /// Report title
    pub title: String,
    /// Report number/identifier
    pub report_number: String,
    /// Version
    pub version: String,
    /// Classification level
    pub classification: Classification,
    /// When the report was generated
    pub generated_at: DateTime<Utc>,
    /// Tool that generated the report
    pub generated_by: String,
}

/// Classification levels for reports
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum Classification {
    /// Public information
    Public,
    /// Internal use only
    Internal,
    /// Confidential
    Confidential,
    /// Restricted access
    Restricted,
    /// Law enforcement sensitive
    LawEnforcementSensitive,
}

impl Classification {
    /// Get display string
    pub fn as_str(&self) -> &'static str {
        match self {
            Classification::Public => "PUBLIC",
            Classification::Internal => "INTERNAL",
            Classification::Confidential => "CONFIDENTIAL",
            Classification::Restricted => "RESTRICTED",
            Classification::LawEnforcementSensitive => "LAW ENFORCEMENT SENSITIVE",
        }
    }
}

/// Case information
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct CaseInfo {
    /// Case number/identifier
    pub case_number: String,
    /// Case name/title
    pub case_name: Option<String>,
    /// Agency or organization
    pub agency: Option<String>,
    /// Requesting party
    pub requestor: Option<String>,
    /// Date examination was requested
    pub request_date: Option<DateTime<Utc>>,
    /// Examination start date
    pub exam_start_date: Option<DateTime<Utc>>,
    /// Examination end date
    pub exam_end_date: Option<DateTime<Utc>>,
    /// Type of investigation
    pub investigation_type: Option<String>,
    /// Brief description
    pub description: Option<String>,
}

/// Examiner information
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct ExaminerInfo {
    /// Examiner's full name
    pub name: String,
    /// Title/position
    pub title: Option<String>,
    /// Organization/agency
    pub organization: Option<String>,
    /// Contact email
    pub email: Option<String>,
    /// Contact phone
    pub phone: Option<String>,
    /// Certifications
    pub certifications: Vec<String>,
    /// Badge/ID number
    pub badge_number: Option<String>,
}

/// Evidence item examined
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EvidenceItem {
    /// Evidence tag/identifier
    pub evidence_id: String,
    /// Description of the item
    pub description: String,
    /// Type of evidence
    pub evidence_type: EvidenceType,
    /// Make/manufacturer
    pub make: Option<String>,
    /// Model
    pub model: Option<String>,
    /// Serial number
    pub serial_number: Option<String>,
    /// Capacity/size
    pub capacity: Option<String>,
    /// Condition when received
    pub condition: Option<String>,
    /// Date received
    pub received_date: Option<DateTime<Utc>>,
    /// Who submitted the evidence
    pub submitted_by: Option<String>,
    /// Hash values at acquisition
    pub acquisition_hashes: Vec<HashRecord>,
    /// Forensic image information
    pub image_info: Option<ImageInfo>,
    /// Notes about this item
    pub notes: Option<String>,
}

/// Types of evidence
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum EvidenceType {
    /// Hard drive (internal)
    HardDrive,
    /// Solid state drive
    SSD,
    /// USB flash drive
    UsbDrive,
    /// External hard drive
    ExternalDrive,
    /// SD card / memory card
    MemoryCard,
    /// Mobile phone
    MobilePhone,
    /// Tablet
    Tablet,
    /// Computer (whole system)
    Computer,
    /// Laptop
    Laptop,
    /// Optical disc (CD/DVD/Blu-ray)
    OpticalDisc,
    /// Cloud storage
    CloudStorage,
    /// Network capture
    NetworkCapture,
    /// Forensic image file
    ForensicImage,
    /// Other
    Other,
}

impl EvidenceType {
    pub fn as_str(&self) -> &'static str {
        match self {
            EvidenceType::HardDrive => "Hard Drive",
            EvidenceType::SSD => "Solid State Drive",
            EvidenceType::UsbDrive => "USB Flash Drive",
            EvidenceType::ExternalDrive => "External Drive",
            EvidenceType::MemoryCard => "Memory Card",
            EvidenceType::MobilePhone => "Mobile Phone",
            EvidenceType::Tablet => "Tablet",
            EvidenceType::Computer => "Computer",
            EvidenceType::Laptop => "Laptop",
            EvidenceType::OpticalDisc => "Optical Disc",
            EvidenceType::CloudStorage => "Cloud Storage",
            EvidenceType::NetworkCapture => "Network Capture",
            EvidenceType::ForensicImage => "Forensic Image",
            EvidenceType::Other => "Other",
        }
    }
}

/// Information about a forensic image
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ImageInfo {
    /// Image format (E01, AD1, RAW, etc.)
    pub format: String,
    /// Image file name(s)
    pub file_names: Vec<String>,
    /// Total size in bytes
    pub total_size: u64,
    /// Number of segments
    pub segments: Option<u32>,
    /// Compression type
    pub compression: Option<String>,
    /// Acquisition tool
    pub acquisition_tool: Option<String>,
    /// Acquisition date
    pub acquisition_date: Option<DateTime<Utc>>,
}

/// Chain of custody record
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CustodyRecord {
    /// Evidence item ID
    pub evidence_id: String,
    /// Date/time of transfer
    pub timestamp: DateTime<Utc>,
    /// Person releasing custody
    pub released_by: String,
    /// Person receiving custody
    pub received_by: String,
    /// Purpose of transfer
    pub purpose: Option<String>,
    /// Location
    pub location: Option<String>,
    /// Notes
    pub notes: Option<String>,
}

/// A finding from the examination
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Finding {
    /// Finding identifier
    pub finding_id: String,
    /// Title/summary
    pub title: String,
    /// Severity/significance
    pub severity: FindingSeverity,
    /// Category of finding
    pub category: FindingCategory,
    /// Detailed description
    pub description: String,
    /// Evidence supporting this finding
    pub supporting_evidence: Vec<String>,
    /// Related file paths
    pub related_files: Vec<String>,
    /// Related timestamps
    pub timestamps: Vec<DateTime<Utc>>,
    /// Screenshots or exhibits
    pub exhibits: Vec<Exhibit>,
    /// Additional notes
    pub notes: Option<String>,
}

/// Severity levels for findings
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum FindingSeverity {
    /// Informational
    Info,
    /// Low significance
    Low,
    /// Medium significance
    Medium,
    /// High significance
    High,
    /// Critical finding
    Critical,
}

impl FindingSeverity {
    pub fn as_str(&self) -> &'static str {
        match self {
            FindingSeverity::Info => "Informational",
            FindingSeverity::Low => "Low",
            FindingSeverity::Medium => "Medium",
            FindingSeverity::High => "High",
            FindingSeverity::Critical => "Critical",
        }
    }
}

/// Categories for findings
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum FindingCategory {
    /// User activity
    UserActivity,
    /// File system artifacts
    FileSystem,
    /// Internet/browser history
    InternetHistory,
    /// Communication (email, chat)
    Communication,
    /// Document access
    Documents,
    /// Media files
    Media,
    /// Deleted data
    DeletedData,
    /// Anti-forensics
    AntiForensics,
    /// Malware/suspicious software
    Malware,
    /// System events
    SystemEvents,
    /// Network activity
    NetworkActivity,
    /// External devices
    ExternalDevices,
    /// Encryption
    Encryption,
    /// Timeline
    Timeline,
    /// Other
    Other,
}

impl FindingCategory {
    pub fn as_str(&self) -> &'static str {
        match self {
            FindingCategory::UserActivity => "User Activity",
            FindingCategory::FileSystem => "File System",
            FindingCategory::InternetHistory => "Internet History",
            FindingCategory::Communication => "Communication",
            FindingCategory::Documents => "Documents",
            FindingCategory::Media => "Media Files",
            FindingCategory::DeletedData => "Deleted Data",
            FindingCategory::AntiForensics => "Anti-Forensics",
            FindingCategory::Malware => "Malware/Suspicious Software",
            FindingCategory::SystemEvents => "System Events",
            FindingCategory::NetworkActivity => "Network Activity",
            FindingCategory::ExternalDevices => "External Devices",
            FindingCategory::Encryption => "Encryption",
            FindingCategory::Timeline => "Timeline Analysis",
            FindingCategory::Other => "Other",
        }
    }
}

/// An exhibit (screenshot, file excerpt, etc.)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Exhibit {
    /// Exhibit identifier
    pub exhibit_id: String,
    /// Title/caption
    pub title: String,
    /// Description
    pub description: Option<String>,
    /// Type of exhibit
    pub exhibit_type: ExhibitType,
    /// File path (for images) or content (for text)
    pub content: String,
    /// Related finding IDs
    pub related_findings: Vec<String>,
}

/// Types of exhibits
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum ExhibitType {
    /// Screenshot image
    Screenshot,
    /// File hex dump
    HexDump,
    /// Text excerpt
    TextExcerpt,
    /// Table/structured data
    Table,
    /// Diagram
    Diagram,
    /// Photo
    Photo,
}

/// Timeline event
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TimelineEvent {
    /// Event timestamp
    pub timestamp: DateTime<Utc>,
    /// Timestamp type (created, modified, accessed, etc.)
    pub timestamp_type: String,
    /// Event description
    pub description: String,
    /// Source of the event
    pub source: String,
    /// Related file or artifact
    pub artifact: Option<String>,
    /// Related evidence ID
    pub evidence_id: Option<String>,
    /// Significance
    pub significance: Option<String>,
}

/// Hash record
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct HashRecord {
    /// Item being hashed
    pub item: String,
    /// Hash algorithm
    pub algorithm: HashAlgorithm,
    /// Hash value (hex string)
    pub value: String,
    /// When the hash was computed
    pub computed_at: Option<DateTime<Utc>>,
    /// Verification status
    pub verified: Option<bool>,
}

/// Supported hash algorithms
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum HashAlgorithm {
    MD5,
    SHA1,
    SHA256,
    SHA512,
    Blake2b,
    Blake3,
}

impl HashAlgorithm {
    pub fn as_str(&self) -> &'static str {
        match self {
            HashAlgorithm::MD5 => "MD5",
            HashAlgorithm::SHA1 => "SHA-1",
            HashAlgorithm::SHA256 => "SHA-256",
            HashAlgorithm::SHA512 => "SHA-512",
            HashAlgorithm::Blake2b => "BLAKE2b",
            HashAlgorithm::Blake3 => "BLAKE3",
        }
    }
}

/// Tool/software information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ToolInfo {
    /// Tool name
    pub name: String,
    /// Version
    pub version: String,
    /// Vendor
    pub vendor: Option<String>,
    /// Purpose in the examination
    pub purpose: Option<String>,
}

/// Appendix
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Appendix {
    /// Appendix identifier (A, B, C, etc.)
    pub appendix_id: String,
    /// Title
    pub title: String,
    /// Content type
    pub content_type: AppendixType,
    /// Content (markdown or path to file)
    pub content: String,
}

/// Types of appendix content
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum AppendixType {
    /// Markdown text
    Markdown,
    /// Raw text
    Text,
    /// File listing
    FileListing,
    /// Hash table
    HashTable,
    /// External file reference
    FileReference,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_report_builder() {
        let report = ForensicReport::builder()
            .case_number("2026-001")
            .examiner_name("John Doe")
            .add_evidence(EvidenceItem {
                evidence_id: "E001".to_string(),
                description: "Test drive".to_string(),
                evidence_type: EvidenceType::HardDrive,
                make: None,
                model: None,
                serial_number: None,
                capacity: None,
                condition: None,
                received_date: None,
                submitted_by: None,
                acquisition_hashes: vec![],
                image_info: None,
                notes: None,
            })
            .executive_summary("This is a test report.")
            .build()
            .expect("Failed to build report");

        assert_eq!(report.case_info.case_number, "2026-001");
        assert_eq!(report.examiner.name, "John Doe");
        assert_eq!(report.evidence_items.len(), 1);
        assert!(report.executive_summary.is_some());
    }

    #[test]
    fn test_report_validation() {
        let report = ForensicReport::builder()
            .case_number("2026-001")
            .examiner_name("John Doe")
            .build()
            .expect("Failed to build report");

        let result = report.validate();
        assert!(result.is_err()); // Should fail - no evidence items
    }
}
