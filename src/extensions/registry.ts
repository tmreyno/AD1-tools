// =============================================================================
// CORE-FFX EXTENSION REGISTRY
// =============================================================================
// Central registry for managing extensions. Handles registration, discovery,
// lifecycle management, and extension lookup.
// =============================================================================

import { createSignal, createRoot } from "solid-js";
import type {
  Extension,
  ExtensionId,
  ExtensionManifest,
  ExtensionState,
  ExtensionCategory,
  DatabaseProcessorExtension,
  ContainerParserExtension,
  ArtifactViewerExtension,
  ExportFormatExtension,
  AnalysisToolExtension,
  IntegrationExtension,
  ArtifactResult,
} from "./types";

// =============================================================================
// REGISTRY STATE
// =============================================================================

/** Internal extension storage */
interface ExtensionEntry {
  extension: Extension;
  state: ExtensionState;
}

// Create reactive state in a root scope
const registryState = createRoot(() => {
  const [extensions, setExtensions] = createSignal<Map<ExtensionId, ExtensionEntry>>(new Map());
  const [loading, setLoading] = createSignal(false);
  const [error, setError] = createSignal<string | null>(null);
  
  return { extensions, setExtensions, loading, setLoading, error, setError };
});

// =============================================================================
// REGISTRATION
// =============================================================================

/**
 * Register an extension with the registry
 */
export async function registerExtension(extension: Extension): Promise<void> {
  const { extensions, setExtensions } = registryState;
  const id = extension.manifest.id;
  
  // Check for duplicate
  if (extensions().has(id)) {
    throw new Error(`Extension already registered: ${id}`);
  }
  
  // Validate manifest
  validateManifest(extension.manifest);
  
  // Create entry
  const entry: ExtensionEntry = {
    extension,
    state: {
      manifest: extension.manifest,
      enabled: false,
      loaded: false,
    },
  };
  
  // Add to registry
  setExtensions((prev) => {
    const next = new Map(prev);
    next.set(id, entry);
    return next;
  });
  
  console.log(`[ExtensionRegistry] Registered: ${extension.manifest.name} (${id})`);
}

/**
 * Unregister an extension
 */
export async function unregisterExtension(id: ExtensionId): Promise<void> {
  const { extensions, setExtensions } = registryState;
  
  const entry = extensions().get(id);
  if (!entry) {
    throw new Error(`Extension not found: ${id}`);
  }
  
  // Disable and unload if needed
  if (entry.state.enabled) {
    await disableExtension(id);
  }
  
  // Remove from registry
  setExtensions((prev) => {
    const next = new Map(prev);
    next.delete(id);
    return next;
  });
  
  console.log(`[ExtensionRegistry] Unregistered: ${id}`);
}

// =============================================================================
// LIFECYCLE MANAGEMENT
// =============================================================================

/**
 * Enable an extension
 */
export async function enableExtension(id: ExtensionId): Promise<void> {
  const { extensions, setExtensions } = registryState;
  
  const entry = extensions().get(id);
  if (!entry) {
    throw new Error(`Extension not found: ${id}`);
  }
  
  if (entry.state.enabled) {
    return; // Already enabled
  }
  
  try {
    // Load if not loaded
    if (!entry.state.loaded && entry.extension.onLoad) {
      await entry.extension.onLoad();
    }
    
    // Enable
    if (entry.extension.onEnable) {
      await entry.extension.onEnable();
    }
    
    // Update state
    setExtensions((prev) => {
      const next = new Map(prev);
      const updated = next.get(id)!;
      updated.state = { ...updated.state, enabled: true, loaded: true, error: undefined };
      return next;
    });
    
    console.log(`[ExtensionRegistry] Enabled: ${id}`);
  } catch (err) {
    const message = err instanceof Error ? err.message : String(err);
    setExtensions((prev) => {
      const next = new Map(prev);
      const updated = next.get(id)!;
      updated.state = { ...updated.state, error: message };
      return next;
    });
    throw err;
  }
}

/**
 * Disable an extension
 */
export async function disableExtension(id: ExtensionId): Promise<void> {
  const { extensions, setExtensions } = registryState;
  
  const entry = extensions().get(id);
  if (!entry) {
    throw new Error(`Extension not found: ${id}`);
  }
  
  if (!entry.state.enabled) {
    return; // Already disabled
  }
  
  try {
    if (entry.extension.onDisable) {
      await entry.extension.onDisable();
    }
    
    setExtensions((prev) => {
      const next = new Map(prev);
      const updated = next.get(id)!;
      updated.state = { ...updated.state, enabled: false };
      return next;
    });
    
    console.log(`[ExtensionRegistry] Disabled: ${id}`);
  } catch (err) {
    const message = err instanceof Error ? err.message : String(err);
    setExtensions((prev) => {
      const next = new Map(prev);
      const updated = next.get(id)!;
      updated.state = { ...updated.state, error: message };
      return next;
    });
    throw err;
  }
}

// =============================================================================
// QUERIES
// =============================================================================

/**
 * Get all registered extensions
 */
export function getAllExtensions(): ExtensionState[] {
  return Array.from(registryState.extensions().values()).map((e) => e.state);
}

/**
 * Get enabled extensions
 */
export function getEnabledExtensions(): Extension[] {
  return Array.from(registryState.extensions().values())
    .filter((e) => e.state.enabled)
    .map((e) => e.extension);
}

/**
 * Get extensions by category
 */
export function getExtensionsByCategory(category: ExtensionCategory): Extension[] {
  return Array.from(registryState.extensions().values())
    .filter((e) => e.state.enabled && e.state.manifest.category === category)
    .map((e) => e.extension);
}

/**
 * Get extension by ID
 */
export function getExtension(id: ExtensionId): Extension | undefined {
  return registryState.extensions().get(id)?.extension;
}

/**
 * Get extension state by ID
 */
export function getExtensionState(id: ExtensionId): ExtensionState | undefined {
  return registryState.extensions().get(id)?.state;
}

// =============================================================================
// SPECIALIZED GETTERS
// =============================================================================

/**
 * Get all database processor extensions
 */
export function getDatabaseProcessors(): DatabaseProcessorExtension[] {
  return getExtensionsByCategory("database-processor") as DatabaseProcessorExtension[];
}

/**
 * Get all container parser extensions
 */
export function getContainerParsers(): ContainerParserExtension[] {
  return getExtensionsByCategory("container-parser") as ContainerParserExtension[];
}

/**
 * Get all artifact viewer extensions
 */
export function getArtifactViewers(): ArtifactViewerExtension[] {
  return getExtensionsByCategory("artifact-viewer") as ArtifactViewerExtension[];
}

/**
 * Find a viewer for an artifact
 */
export function findViewerForArtifact(artifact: ArtifactResult): ArtifactViewerExtension | undefined {
  const viewers = getArtifactViewers()
    .filter((v) => v.canHandle(artifact))
    .sort((a, b) => (b.priority ?? 0) - (a.priority ?? 0));
  
  return viewers[0];
}

/**
 * Get all export format extensions
 */
export function getExportFormats(): ExportFormatExtension[] {
  return getExtensionsByCategory("export-format") as ExportFormatExtension[];
}

/**
 * Get all analysis tool extensions
 */
export function getAnalysisTools(): AnalysisToolExtension[] {
  return getExtensionsByCategory("analysis-tool") as AnalysisToolExtension[];
}

/**
 * Get all integration extensions
 */
export function getIntegrations(): IntegrationExtension[] {
  return getExtensionsByCategory("integration") as IntegrationExtension[];
}

// =============================================================================
// VALIDATION
// =============================================================================

function validateManifest(manifest: ExtensionManifest): void {
  if (!manifest.id || typeof manifest.id !== "string") {
    throw new Error("Extension manifest must have a valid id");
  }
  
  if (!manifest.name || typeof manifest.name !== "string") {
    throw new Error("Extension manifest must have a valid name");
  }
  
  if (!manifest.version || typeof manifest.version !== "string") {
    throw new Error("Extension manifest must have a valid version");
  }
  
  if (!manifest.category) {
    throw new Error("Extension manifest must have a category");
  }
  
  // Validate ID format (reverse domain notation recommended)
  if (!/^[a-z0-9-]+(\.[a-z0-9-]+)*$/i.test(manifest.id)) {
    console.warn(
      `[ExtensionRegistry] Extension ID "${manifest.id}" doesn't follow recommended format (e.g., "com.example.my-extension")`
    );
  }
}

// =============================================================================
// HOOKS FOR COMPONENTS
// =============================================================================

/**
 * Hook to get reactive extension list
 */
export function useExtensions() {
  return {
    extensions: registryState.extensions,
    loading: registryState.loading,
    error: registryState.error,
    
    // Actions
    register: registerExtension,
    unregister: unregisterExtension,
    enable: enableExtension,
    disable: disableExtension,
    
    // Queries
    getAll: getAllExtensions,
    getEnabled: getEnabledExtensions,
    getByCategory: getExtensionsByCategory,
    get: getExtension,
    getState: getExtensionState,
    
    // Specialized
    getDatabaseProcessors,
    getContainerParsers,
    getArtifactViewers,
    getExportFormats,
    getAnalysisTools,
    getIntegrations,
    findViewerForArtifact,
  };
}

// =============================================================================
// INITIALIZATION
// =============================================================================

/**
 * Initialize the extension registry (load built-in and saved extensions)
 */
export async function initializeRegistry(): Promise<void> {
  const { setLoading, setError } = registryState;
  
  setLoading(true);
  setError(null);
  
  try {
    // TODO: Load extensions from disk/storage
    // TODO: Load extension settings from database
    // TODO: Auto-enable previously enabled extensions
    
    console.log("[ExtensionRegistry] Initialized");
  } catch (err) {
    const message = err instanceof Error ? err.message : String(err);
    setError(message);
    console.error("[ExtensionRegistry] Initialization error:", err);
  } finally {
    setLoading(false);
  }
}
