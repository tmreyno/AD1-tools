import { Show, createSignal, createEffect } from "solid-js";
import type { DiscoveredFile, ContainerInfo, TreeEntry, SegmentHashResult, HashHistoryEntry, HashAlgorithm, StoredHash } from "../types";
import type { FileStatus, FileHashInfo } from "../hooks";
import { DetailPanelContent } from "./DetailPanelContent";
import { HexViewer } from "./HexViewer";
import type { ParsedMetadata } from "./HexViewer";
import { TextViewer } from "./TextViewer";
import { TabBar } from "./TabBar";
import type { TabViewMode, OpenTab } from "./TabBar";

// Re-export TabViewMode and OpenTab for backward compatibility
export type { TabViewMode, OpenTab };

interface DetailPanelProps {
  // Current active file from file manager
  activeFile: DiscoveredFile | null;
  // Accessors to get info maps (must be functions for reactivity)
  fileInfoMap: () => Map<string, ContainerInfo>;
  fileStatusMap: () => Map<string, FileStatus>;
  fileHashMap: () => Map<string, FileHashInfo>;
  hashHistory: () => Map<string, HashHistoryEntry[]>;
  segmentResults: () => Map<string, SegmentHashResult[]>;
  // Tree data for active tab
  tree: TreeEntry[];
  filteredTree: TreeEntry[];
  treeFilter: string;
  onTreeFilterChange: (filter: string) => void;
  // Other props
  selectedHashAlgorithm: HashAlgorithm;
  segmentVerifyProgress: { segment: string; percent: number; completed: number; total: number } | null;
  storedHashesGetter: (info: ContainerInfo | undefined) => StoredHash[];
  busy: boolean;
  onVerifySegments: (file: DiscoveredFile) => void;
  onLoadInfo: (file: DiscoveredFile) => void;
  formatHashDate: (timestamp: string) => string;
  // Tab switching callback (to update file manager's active file, null = all tabs closed)
  onTabSelect: (file: DiscoveredFile | null) => void;
  // Callback to notify parent of tab changes (for project save)
  onTabsChange?: (tabs: OpenTab[]) => void;
  // Callback when metadata is loaded from hex viewer (for right panel)
  onMetadataLoaded?: (metadata: ParsedMetadata | null) => void;
  // Callback when view mode changes (for right panel switching)
  onViewModeChange?: (mode: TabViewMode) => void;
  // Callback when hex viewer navigation is ready (for metadata panel to navigate)
  onHexNavigatorReady?: (navigateTo: (offset: number, size?: number) => void) => void;
  // Request to change view mode from parent (for metadata panel navigation)
  requestViewMode?: TabViewMode | null;
  // Callback to clear the view mode request after processing
  onViewModeRequestHandled?: () => void;
}

export function DetailPanel(props: DetailPanelProps) {
  // Tab state
  const [openTabs, setOpenTabs] = createSignal<OpenTab[]>([]);
  const [activeTabId, setActiveTabId] = createSignal<string | null>(null);
  // Track recently closed tabs to prevent immediate re-opening
  const [recentlyClosed, setRecentlyClosed] = createSignal<Set<string>>(new Set());
  // Track view mode per tab (default to "info")
  const [tabViewModes, setTabViewModes] = createSignal<Map<string, TabViewMode>>(new Map());
  
  // Notify parent of tab changes (for project save)
  createEffect(() => {
    const tabs = openTabs();
    if (props.onTabsChange) {
      props.onTabsChange(tabs);
    }
  });
  
  // Handle view mode request from parent (e.g., from MetadataPanel click)
  createEffect(() => {
    const requestedMode = props.requestViewMode;
    if (requestedMode) {
      const id = activeTabId();
      if (id) {
        setTabViewModes(prev => {
          const next = new Map(prev);
          next.set(id, requestedMode);
          return next;
        });
        // Notify parent of view mode change
        if (props.onViewModeChange) {
          props.onViewModeChange(requestedMode);
        }
      }
      // Clear the request
      if (props.onViewModeRequestHandled) {
        props.onViewModeRequestHandled();
      }
    }
  });
  
  // When activeFile changes from file manager, open it as a tab
  createEffect(() => {
    const file = props.activeFile;
    if (!file) return;
    
    // Don't re-open recently closed tabs (prevents immediate re-opening)
    if (recentlyClosed().has(file.path)) {
      return;
    }
    
    // Clear recently closed when opening a new/different file
    // This allows previously closed files to be re-opened on explicit click
    if (recentlyClosed().size > 0) {
      setRecentlyClosed(new Set<string>());
    }
    
    const tabs = openTabs();
    const currentActiveId = activeTabId();
    const existingTabIndex = tabs.findIndex(t => t.id === file.path);
    
    if (existingTabIndex >= 0) {
      // Tab already exists - only update if not already active (prevents infinite loops)
      if (currentActiveId !== file.path) {
        setActiveTabId(file.path);
      }
      // Don't update tab data here - it causes unnecessary re-renders
    } else {
      // Add new tab
      const newTab: OpenTab = { file, id: file.path };
      setOpenTabs([...tabs, newTab]);
      setActiveTabId(file.path);
    }
  });
  
  // Get the currently active tab's file
  const activeTab = () => {
    const id = activeTabId();
    if (!id) return null;
    return openTabs().find(t => t.id === id) ?? null;
  };
  
  // Close a tab
  const closeTab = (tabId: string, e?: MouseEvent) => {
    e?.stopPropagation();
    e?.preventDefault();
    
    const tabs = openTabs();
    const tabIndex = tabs.findIndex(t => t.id === tabId);
    if (tabIndex === -1) return;
    
    // Mark as recently closed to prevent re-opening from activeFile prop
    setRecentlyClosed(prev => new Set([...prev, tabId]));
    
    const newTabs = tabs.filter(t => t.id !== tabId);
    setOpenTabs(newTabs);
    
    // If we closed the active tab, activate another
    if (activeTabId() === tabId) {
      if (newTabs.length > 0) {
        // Activate the tab to the left, or the first tab
        const newActiveIndex = Math.min(tabIndex, newTabs.length - 1);
        const newActiveTab = newTabs[newActiveIndex];
        setActiveTabId(newActiveTab.id);
        props.onTabSelect(newActiveTab.file);
      } else {
        setActiveTabId(null);
        // Notify parent that no tabs are open
        props.onTabSelect(null);
      }
    }
  };
  
  // Close all tabs except the given one
  const closeOtherTabs = (keepTabId: string) => {
    const tabs = openTabs();
    const keepTab = tabs.find(t => t.id === keepTabId);
    if (keepTab) {
      // Mark closed tabs as recently closed
      const closedIds = tabs.filter(t => t.id !== keepTabId).map(t => t.id);
      setRecentlyClosed(prev => new Set([...prev, ...closedIds]));
      
      setOpenTabs([keepTab]);
      setActiveTabId(keepTabId);
      props.onTabSelect(keepTab.file);
    }
  };
  
  // Close all tabs
  const closeAllTabs = () => {
    // Mark all tabs as recently closed
    const closedIds = openTabs().map(t => t.id);
    setRecentlyClosed(prev => new Set([...prev, ...closedIds]));
    
    setOpenTabs([]);
    setActiveTabId(null);
    // Notify parent that no tabs are open
    props.onTabSelect(null);
  };
  
  // Select a tab
  const selectTab = (tab: OpenTab) => {
    setActiveTabId(tab.id);
    props.onTabSelect(tab.file);
  };
  
  // Move tab to a new position
  const moveTab = (fromIndex: number, toIndex: number) => {
    if (fromIndex === toIndex) return;
    const tabs = [...openTabs()];
    const [movedTab] = tabs.splice(fromIndex, 1);
    tabs.splice(toIndex, 0, movedTab);
    setOpenTabs(tabs);
  };
  
  // Get data for active tab
  const activeTabFile = () => activeTab()?.file ?? null;
  const activeFileInfo = () => {
    const file = activeTabFile();
    return file ? props.fileInfoMap().get(file.path) : undefined;
  };
  const activeFileHash = () => {
    const file = activeTabFile();
    return file ? props.fileHashMap().get(file.path) : undefined;
  };
  const activeFileStatus = () => {
    const file = activeTabFile();
    return file ? props.fileStatusMap().get(file.path) : undefined;
  };
  const activeFileSegmentResults = () => {
    const file = activeTabFile();
    return file ? props.segmentResults().get(file.path) ?? [] : [];
  };
  const activeFileHashHistory = () => {
    const file = activeTabFile();
    return file ? props.hashHistory().get(file.path) ?? [] : [];
  };
  
  // Get current view mode for active tab
  const getActiveViewMode = (): TabViewMode => {
    const id = activeTabId();
    if (!id) return "info";
    return tabViewModes().get(id) ?? "info";
  };
  
  // Set view mode for active tab
  const setActiveViewMode = (mode: TabViewMode) => {
    const id = activeTabId();
    if (!id) return;
    setTabViewModes(prev => {
      const next = new Map(prev);
      next.set(id, mode);
      return next;
    });
    // Notify parent of view mode change
    if (props.onViewModeChange) {
      props.onViewModeChange(mode);
    }
  };
  
  return (
    <div class="tabbed-detail-panel">
      {/* Tab bar component */}
      <TabBar
        tabs={openTabs()}
        activeTabId={activeTabId()}
        viewMode={getActiveViewMode()}
        onTabSelect={selectTab}
        onTabClose={closeTab}
        onCloseOthers={closeOtherTabs}
        onCloseAll={closeAllTabs}
        onTabMove={moveTab}
        onViewModeChange={setActiveViewMode}
      />
      
      {/* Content area - switches based on view mode */}
      <div class="detail-content-area">
        {/* Info view (default) */}
        <Show when={getActiveViewMode() === "info"}>
          <DetailPanelContent
            activeFile={activeTabFile()}
            fileInfo={activeFileInfo()}
            fileHash={activeFileHash()}
            fileStatus={activeFileStatus()}
            tree={props.tree}
            filteredTree={props.filteredTree}
            treeFilter={props.treeFilter}
            onTreeFilterChange={props.onTreeFilterChange}
            selectedHashAlgorithm={props.selectedHashAlgorithm}
            segmentResults={activeFileSegmentResults()}
            segmentVerifyProgress={props.segmentVerifyProgress}
            hashHistory={activeFileHashHistory()}
            storedHashes={props.storedHashesGetter(activeFileInfo())}
            busy={props.busy}
            onVerifySegments={() => activeTabFile() && props.onVerifySegments(activeTabFile()!)}
            onLoadInfo={() => activeTabFile() && props.onLoadInfo(activeTabFile()!)}
            formatHashDate={props.formatHashDate}
          />
        </Show>
        
        {/* Hex view */}
        <Show when={getActiveViewMode() === "hex" && activeTabFile()}>
          <HexViewer
            file={activeTabFile()!}
            onMetadataLoaded={props.onMetadataLoaded}
            onNavigatorReady={props.onHexNavigatorReady}
          />
        </Show>
        
        {/* Text view */}
        <Show when={getActiveViewMode() === "text" && activeTabFile()}>
          <TextViewer
            file={activeTabFile()!}
          />
        </Show>
      </div>
    </div>
  );
}
